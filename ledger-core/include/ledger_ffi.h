/* Ledger Core FFI - C API Interface */
/* Generated by cbindgen - Do not modify */

#ifndef LEDGER_CORE_FFI_H
#define LEDGER_CORE_FFI_H

#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/*
 C-compatible transaction status

 Represents the clearing status of a transaction in the ledger.
 */
typedef enum CTransactionStatus {
    /*
     Transaction is uncleared (default state)
     */
    Uncleared = 0,
    /*
     Transaction has been cleared/reconciled
     */
    Cleared = 1,
    /*
     Transaction is pending clearance
     */
    Pending = 2,
} CTransactionStatus;

/*
 FFI error codes for cross-boundary error handling

 These error codes are returned by FFI functions to indicate
 success or various failure conditions. Always check return values.
 */
typedef enum LedgerResult {
    /*
     Operation completed successfully
     */
    LedgerOk = 0,
    /*
     Generic error - check ledger_get_last_error() for details
     */
    LedgerError = 1,
    /*
     Null pointer passed to function
     */
    LedgerNullPtr = 2,
    /*
     String contains invalid UTF-8 data
     */
    LedgerInvalidUtf8 = 3,
    /*
     Failed to parse input data
     */
    LedgerParseError = 4,
    /*
     Memory allocation failed
     */
    LedgerMemoryError = 5,
    /*
     Type conversion failed
     */
    LedgerTypeError = 6,
} LedgerResult;

typedef struct Option_ErrorCallback Option_ErrorCallback;

typedef struct Option_ProgressCallback Option_ProgressCallback;

typedef struct PostingFlags PostingFlags;

/*
 Reference counted journal handle
 */
typedef struct RcJournal RcJournal;

typedef struct TransactionFlags TransactionFlags;

/*
 Opaque pointer wrapper for Transaction
 */
typedef struct CTransaction {
    uint8_t _private[0];
} CTransaction;

/*
 Opaque pointer wrapper for Amount
 */
typedef struct CAmount {
    uint8_t _private[0];
} CAmount;

/*
 Opaque pointer wrapper for Journal
 */
typedef struct CJournal {
    uint8_t _private[0];
} CJournal;

/*
 C-compatible date structure

 Represents a calendar date with year, month (1-12), and day (1-31).
 Used for transaction dates and other temporal data.
 */
typedef struct CDate {
    /*
     Year (e.g., 2023)
     */
    int year;
    /*
     Month (1-12)
     */
    int month;
    /*
     Day of month (1-31)
     */
    int day;
} CDate;

/*
 Function pointer type for transaction iteration callback

 Parameters:
 - transaction: Read-only access to transaction
 - user_data: User-provided context pointer

 Returns: true to continue iteration, false to stop
 */
typedef bool (*TransactionCallback)(const struct CTransaction *transaction, void *user_data);

/*
 Opaque pointer wrapper for Posting
 */
typedef struct CPosting {
    uint8_t _private[0];
} CPosting;

/*
 Function pointer type for posting iteration callback

 Parameters:
 - posting: Read-only access to posting
 - user_data: User-provided context pointer

 Returns: true to continue iteration, false to stop
 */
typedef bool (*PostingCallback)(const struct CPosting *posting, void *user_data);

/*
 Asynchronous-style callback for batch processing

 Processes transactions in batches, calling the batch callback for each batch.
 Useful for parallel processing or memory-conscious operations.

 Parameters:
 - journal: Journal to process
 - batch_size: Number of transactions per batch
 - batch_callback: Called once per batch
 - user_data: User context
 */
typedef bool (*BatchCallback)(const struct CTransaction *const *transactions,
                              int count,
                              int batch_num,
                              void *user_data);

/*
 Opaque pointer wrapper for Balance
 */
typedef struct CBalance {
    uint8_t _private[0];
} CBalance;

/*
 Opaque pointer wrapper for Account
 */
typedef struct CAccount {
    uint8_t _private[0];
} CAccount;

/*
 Error callback function type
 */
typedef void (*ErrorCallback)(int code, const char *message, const char *context);































#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*
 Get the last error code
 */
 enum LedgerResult ledger_get_last_error_code(void) ;

/*
 Get the last error message
 */
 const char *ledger_get_last_error(void) ;

/*
 Get the last error context (if any)
 */
 const char *ledger_get_last_error_context(void) ;

/*
 Clear the last error
 */
 void ledger_clear_last_error(void) ;

/*
 Check if there is a pending error
 */
 bool ledger_has_error(void) ;

/*
 Register an error callback for async error reporting
 */
 void ledger_register_error_callback(struct Option_ErrorCallback callback) ;

/*
 Get the legacy error message (deprecated - use ledger_get_last_error)
 */
 const char *ledger_get_legacy_error(void) ;

/*
 Free a C string allocated by this library

 MEMORY SAFETY: Only call this on strings returned by ledger_*_copy_* functions.
 DO NOT call this on strings returned by ledger_*_get_* functions (those are borrowed).
 */
 void ledger_free_string(char *s) ;

/*
 Copy transaction payee string (caller must free with ledger_free_string)

 MEMORY MANAGEMENT: Unlike ledger_transaction_get_payee(), this function
 returns a newly allocated string that the caller owns and must free.
 */
 char *ledger_transaction_copy_payee(const struct CTransaction *transaction) ;

/*
 Copy amount commodity string (caller must free with ledger_free_string)

 MEMORY MANAGEMENT: Returns owned string that must be freed, or NULL if no commodity.
 */
 char *ledger_amount_copy_commodity(const struct CAmount *amount) ;

/*
 Create a new journal

 OWNERSHIP: Returns owned pointer. Caller must call ledger_journal_free().
 */
 struct CJournal *ledger_journal_new(void) ;

/*
 Free a journal and all owned transactions

 OWNERSHIP: Takes ownership of journal pointer. Do not use after calling.
 */
 void ledger_journal_free(struct CJournal *journal) ;

/*
 Get the number of transactions in a journal
 */
 int ledger_journal_transaction_count(const struct CJournal *journal) ;

/*
 Add a transaction to a journal

 OWNERSHIP: Takes ownership of transaction pointer. Do not free transaction after this call.
 The journal will free the transaction when the journal is freed.
 */

enum LedgerResult ledger_journal_add_transaction(struct CJournal *journal,
                                                 struct CTransaction *transaction)
;

/*
 Create a new transaction with minimal required fields
 */
 struct CTransaction *ledger_transaction_new(struct CDate date, const char *payee) ;

/*
 Free a transaction
 */
 void ledger_transaction_free(struct CTransaction *transaction) ;

/*
 Get transaction date
 */
 struct CDate ledger_transaction_get_date(const struct CTransaction *transaction) ;

/*
 Get transaction payee (returns pointer to internal string - do not free!)
 */
 const char *ledger_transaction_get_payee(const struct CTransaction *transaction) ;

/*
 Get transaction status
 */
 enum CTransactionStatus ledger_transaction_get_status(const struct CTransaction *transaction) ;

/*
 Set transaction status
 */

enum LedgerResult ledger_transaction_set_status(struct CTransaction *transaction,
                                                enum CTransactionStatus status)
;

/*
 Get number of postings in transaction
 */
 int ledger_transaction_posting_count(const struct CTransaction *transaction) ;

/*
 Create a new amount from a double value
 */
 struct CAmount *ledger_amount_new(double value) ;

/*
 Create a new amount with commodity
 */
 struct CAmount *ledger_amount_new_with_commodity(double value, const char *commodity) ;

/*
 Free an amount
 */
 void ledger_amount_free(struct CAmount *amount) ;

/*
 Get the numeric value of an amount as double
 */
 double ledger_amount_get_value(const struct CAmount *amount) ;

/*
 Get the commodity of an amount (returns NULL if no commodity)
 */
 const char *ledger_amount_get_commodity(const struct CAmount *amount) ;

/*
 Iterate through all transactions in a journal

 CALLBACK SAFETY: The callback function must not store the transaction pointer
 for use after the callback returns, as it may become invalid.
 */

enum LedgerResult ledger_journal_iterate_transactions(const struct CJournal *journal,
                                                      TransactionCallback callback,
                                                      void *user_data)
;

/*
 Iterate through all postings in a transaction

 CALLBACK SAFETY: The callback function must not store the posting pointer
 for use after the callback returns, as it may become invalid.
 */

enum LedgerResult ledger_transaction_iterate_postings(const struct CTransaction *transaction,
                                                      PostingCallback callback,
                                                      void *user_data)
;

/*
 Filter transactions using a predicate callback

 Creates a new journal containing only transactions for which the callback returns true.

 OWNERSHIP: Returns owned journal pointer. Caller must free with ledger_journal_free().
 CALLBACK SAFETY: Transaction pointers are only valid during callback execution.
 */

struct CJournal *ledger_journal_filter_transactions(const struct CJournal *journal,
                                                    TransactionCallback predicate,
                                                    void *user_data)
;

/*
 Count transactions matching a predicate

 CALLBACK SAFETY: Transaction pointers are only valid during callback execution.
 */

int ledger_journal_count_matching_transactions(const struct CJournal *journal,
                                               TransactionCallback predicate,
                                               void *user_data)
;

/*
 Progress-enabled transaction processing

 Iterates through transactions with progress callbacks for long operations.

 CALLBACK SAFETY: Both callback pointers are only valid during callback execution.
 */

enum LedgerResult ledger_journal_process_transactions_with_progress(const struct CJournal *journal,
                                                                    TransactionCallback transaction_callback,
                                                                    struct Option_ProgressCallback progress_callback,
                                                                    void *user_data)
;

/*
 Process transactions in batches

 CALLBACK SAFETY: Transaction pointers in the batch are only valid during callback execution.
 The batch array itself is also only valid during the callback.
 */

enum LedgerResult ledger_journal_process_in_batches(const struct CJournal *journal,
                                                    int batch_size,
                                                    BatchCallback batch_callback,
                                                    void *user_data)
;

/*
 Create a new reference-counted journal
 */
 struct RcJournal *ledger_rc_journal_new(void) ;

/*
 Clone a reference to the journal (increment reference count)
 */
 struct RcJournal *ledger_rc_journal_clone(const struct RcJournal *journal) ;

/*
 Free a reference-counted journal handle
 */
 void ledger_rc_journal_free(struct RcJournal *journal) ;

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#ifdef __cplusplus
}
#endif

#endif /* LEDGER_CORE_FFI_H */
