name: CMake

on:
  push:
    branches: master
  pull_request:
    branches: master

env:
  # Customize the CMake build type here (Release, Debug, RelWithDebInfo, etc.)
  BUILD_TYPE: Debug
  # Minimum line coverage percentage required. Raise this as coverage improves.
  MIN_COVERAGE: 85

jobs:
  build:
    runs-on: ${{ matrix.config.os }}
    strategy:
      fail-fast: false
      matrix:
        # os: [ubuntu-latest,macos-latest]
        config:
          - {
            os: ubuntu-latest,
            name: Ubuntu,
            PY_MAJOR: 3,
            cmake_args: -DUSE_PYTHON=ON -DUSE_GPGME=ON
          }
          - {
            os: macos-latest,
            name: MacOS,
            PY_MAJOR: 3,
            cmake_args: -DUSE_PYTHON=ON -DUSE_GPGME=ON
          }
          - {
            os: ubuntu-latest,
            name: Ubuntu-Sanitizers,
            PY_MAJOR: 3,
            cmake_args: -DUSE_SANITIZERS=ON
          }
    steps:
      - uses: actions/checkout@v6
        name: Check out repository code

      - if: runner.os == 'Linux'
        name: Linux dependencies
        run: |
          sudo apt-get update -y
          sudo ./acprep dependencies --python

      - if: runner.os == 'macOS'
        name: Mac Dependencies
        run: |
          # Unlink and re-link to prevent errors when github mac runner images
          # install python outside of brew, for example:
          # https://github.com/orgs/Homebrew/discussions/3895
          # https://github.com/actions/setup-python/issues/577
          # https://github.com/actions/runner-images/issues/6459
          # https://github.com/actions/runner-images/issues/6507
          # https://github.com/actions/runner-images/issues/2322
          brew list -1 | grep python | while read formula; do brew unlink $formula; brew link --overwrite $formula; done

          brew update
          brew uninstall cmake
          ./acprep dependencies --python

      - name: Configure CMake
        # Configure CMake in a 'build' subdirectory. `CMAKE_BUILD_TYPE` is only required if you are using a single-configuration generator such as make.
        # See https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html?highlight=cmake_build_type
        run: cmake -B ${{github.workspace}}/build -DCMAKE_BUILD_TYPE=${{env.BUILD_TYPE}} ${{matrix.config.cmake_args}} -DPython_FIND_VERSION_MAJOR=${{matrix.config.PY_MAJOR}}
        env:
          BOOST_ROOT: ${{ steps.install-boost.outputs.BOOST_ROOT }}

      - name: Build
        # Build your program with the given configuration
        run: cmake --build ${{github.workspace}}/build --config ${{env.BUILD_TYPE}}
        env:
          BOOST_ROOT: ${{ steps.install-boost.outputs.BOOST_ROOT }}

      - name: Test
        working-directory: ${{github.workspace}}/build
        # Execute tests defined by the CMake configuration.
        # See https://cmake.org/cmake/help/latest/manual/ctest.1.html for more detail
        run: ctest -C ${{env.BUILD_TYPE}} || ctest -C ${{env.BUILD_TYPE}} --rerun-failed --output-on-failure
        env:
          # Sanitizer output is redirected to log files via log_path to prevent
          # it from contaminating stderr, which the test harness compares against
          # expected output. Sanitizer findings are reported in a separate step.
          ASAN_OPTIONS: ${{ contains(matrix.config.cmake_args, 'USE_SANITIZERS') && 'detect_leaks=1:halt_on_error=0:log_path=/tmp/asan_log' || '' }}
          LSAN_OPTIONS: ${{ contains(matrix.config.cmake_args, 'USE_SANITIZERS') && 'suppressions=../lsan-suppressions.txt:log_path=/tmp/lsan_log' || '' }}
          UBSAN_OPTIONS: ${{ contains(matrix.config.cmake_args, 'USE_SANITIZERS') && 'print_stacktrace=1:halt_on_error=0:suppressions=../ubsan-suppressions.txt:log_path=/tmp/ubsan_log' || '' }}

      - name: Report sanitizer findings
        if: contains(matrix.config.cmake_args, 'USE_SANITIZERS') && always()
        run: |
          echo "=== Sanitizer Report ==="
          found=0
          for prefix in asan_log lsan_log ubsan_log; do
            files=(/tmp/${prefix}.*)
            [ -f "${files[0]}" ] || continue
            echo "--- ${prefix}: ${#files[@]} report(s) ---"
            # Deduplicate: extract unique error summaries
            grep -h "SUMMARY\|ERROR\|runtime error" "${files[@]}" 2>/dev/null | sort -u || true
            echo
            found=1
          done
          if [ "$found" -eq 0 ]; then
            echo "No sanitizer issues found."
          else
            echo "::warning::Sanitizer issues were detected. See above for details."
          fi

  coverage:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        name: Check out repository code

      - name: Install dependencies
        run: |
          sudo apt-get update -y
          sudo ./acprep dependencies
          sudo apt-get install -y lcov

      - name: Configure CMake
        run: cmake -B ${{github.workspace}}/build -DCMAKE_BUILD_TYPE=Debug -DUSE_GCOV=ON -DDISABLE_ASSERTS=ON

      - name: Build
        run: cmake --build ${{github.workspace}}/build --config Debug

      - name: Test
        working-directory: ${{github.workspace}}/build
        run: ctest -C Debug || ctest -C Debug --rerun-failed --output-on-failure

      - name: Generate coverage report
        working-directory: ${{github.workspace}}/build
        run: |
          lcov --capture --directory . --output-file coverage.info --ignore-errors mismatch
          lcov --remove coverage.info '/usr/*' '*/test/*' --ignore-errors unused --output-file coverage.info
          lcov --summary coverage.info
          genhtml coverage.info --output-directory coverage-report

      - name: Check coverage threshold
        working-directory: ${{github.workspace}}/build
        run: |
          COVERAGE=$(lcov --summary coverage.info 2>&1 | grep "lines\.\.\.\.\.\." | sed 's/.*: \([0-9.]*\)%.*/\1/')
          echo "Line coverage: ${COVERAGE}%"
          echo "Minimum threshold: ${{env.MIN_COVERAGE}}%"
          if ! awk "BEGIN{exit ($COVERAGE >= ${{env.MIN_COVERAGE}}) ? 0 : 1}"; then
            echo "::error::Line coverage ${COVERAGE}% is below the minimum threshold of ${{env.MIN_COVERAGE}}%"
            exit 1
          fi
          echo "Coverage check passed: ${COVERAGE}% >= ${{env.MIN_COVERAGE}}%"

      - uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: ${{github.workspace}}/build/coverage-report/
          retention-days: 30
          if-no-files-found: error
